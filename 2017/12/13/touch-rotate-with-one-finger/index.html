<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="6K"><title>DOM 单触点旋转的探索 · 6K</title><meta name="description" content="由于 hammerjs 的 rotate 行为不支持单触点，所以只能另辟蹊径。搜索后发现了一个比较好用的 Library

Propeller - JavaScript library to rotate elements with mouse or touch gestures.

读了下源码，其"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/blog/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/blog/css/style.css"><link rel="stylesheet" href="/blog/css/blog_basic.css"><link rel="stylesheet" href="/blog/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/blog/images/avatar.png" style="width:150px;"><h3 title=""><a href="/">6K</a></h3><div class="description"><p>认真做事 低调做人</p></div></div></div><ul class="social-links"></ul></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/blog/">首页</a></li><li><a href="https://l19861225q.github.io/blog/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"></a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>DOM 单触点旋转的探索</a></h3></div><div class="post-content"><p>由于 <code>hammerjs</code> 的 rotate 行为不支持单触点，所以只能另辟蹊径。搜索后发现了一个比较好用的 Library</p>
<blockquote>
<p><a href="https://github.com/PixelsCommander/Propeller" target="_blank" rel="noopener">Propeller</a> - JavaScript library to rotate elements with mouse or touch gestures.</p>
</blockquote>
<p>读了下源码，其实现原理是监听一些事件，然后通过各种数学函数（sin, tan…），根据位移差值计算旋转角度，最后再更新 DOM 的 CSS（transform: rotate）达到旋转的效果。根据浏览器的兼容性，渐进使用了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">RAF</a><br>提升动画的帧数使其平滑展现。</p>
<h3 id="旋转方向的问题"><a href="#旋转方向的问题" class="headerlink" title="旋转方向的问题"></a>旋转方向的问题</h3><p>实际需求是要限制 DOM 的旋转方向，只可以顺时针旋转。官方尚未支持这个配置，但有提供部分事件钩子：<br><code>onRotate</code>, <code>onDragStart</code> …</p>
<p>期初，是想在 <code>onDragStart</code> 中根据 this.angle 判断是顺/逆时针旋转。发现这个事件是拖拽开始时才触发一次，此时并不能获取到 angle：即 this.angle = 0。又翻看了源码，只有在 <code>onRotate</code>时能获取到 angle（通过 RAF，每隔一段时间监听 evt.touches 的 X, Y 位移差值，通过数学公式计算旋转角度）。</p>
<p>源码中计算角度差并更新 DOM 的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  <span class="built_in">Math</span>.abs(<span class="keyword">this</span>.lastAppliedAngle - <span class="keyword">this</span>._angle) &gt;= <span class="keyword">this</span>.minimalAngleChange &amp;&amp;  <span class="keyword">this</span>.transiting === <span class="literal">false</span></span><br><span class="line">) &#123;</span><br><span class="line"> <span class="keyword">this</span>.updateCSS();</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">this</span>.lastAppliedAngle = <span class="keyword">this</span>._angle; <span class="comment">//  将本次的 angle 赋值给 lastAppliedAngle</span></span><br></pre></td></tr></table></figure></p>
<p>看来是取了绝对值，没有办法通过正负数来判断旋转的方向了。</p>
<h4 id="两个关键的变量"><a href="#两个关键的变量" class="headerlink" title="两个关键的变量"></a>两个关键的变量</h4><ul>
<li><code>this.angle</code> - 本次旋转的角度值</li>
<li><code>this.lastAppliedAngle</code> - 相邻最近旋转的一次的角度值（= this.angle），用来计算角度差值，默认是</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.angle = options.angle || defaults.angle</span><br><span class="line"><span class="keyword">this</span>.lastAppliedAngle = <span class="keyword">this</span>.virtualAngle = <span class="keyword">this</span>._angle = options.angle || defaults.angle;</span><br></pre></td></tr></table></figure>
<h4 id="逆时针旋转和复位"><a href="#逆时针旋转和复位" class="headerlink" title="逆时针旋转和复位"></a>逆时针旋转和复位</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onRotate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> angleDiff = <span class="keyword">this</span>.angle - <span class="keyword">this</span>.lastAppliedAngle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (angleDiff &lt; <span class="number">0</span> &amp;&amp; angleDiff &gt; <span class="number">-350</span>) &#123;</span><br><span class="line">    <span class="comment">// 逆时针旋转，停止旋转，让 DOM 复位</span></span><br><span class="line">    <span class="keyword">this</span>.stop();</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果逆时针旋转，this.angle 取值 &lt; 0，而 this.lastAppliedAngle &gt; this.angle，所以 angleDiff &lt; 0， 通过 angleDiff &lt; 0 可以判断是否进行了逆时针旋转。</p>
<p>但是现在有个问题，当旋转了一圈再次回到0度时，DOM 不能再次旋转了</p>
<blockquote>
<p>这是因为，旋转一圈再次划过0度触发 onRotate 时，this.lastAppliedAngle = 350（测试几次发现，这个范围和触发 onRotate 的频率有关，大概在 350 ~ 359 度之间），而 this.angle 大概在 0 ~ 10 度之间。所以 angleDiff = 0 - (350 ~ 359) = -350 ~ -359 度之间，进入了逆时针判断的逻辑。这时还需加上临界点，所以有了 <code>angleDiff &gt; -350</code> 的边界。</p>
</blockquote>
<h4 id="重置-propeller"><a href="#重置-propeller" class="headerlink" title="重置 propeller"></a>重置 propeller</h4><blockquote>
<p>用来重置 DOM 为初始角度，这里直接使用了 this，所以调用时注意 Scope</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> propellerReset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._angle = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.updateCSS();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="完整的-onRotate"><a href="#完整的-onRotate" class="headerlink" title="完整的 onRotate"></a>完整的 onRotate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">onRotate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> angleDiff =  <span class="keyword">this</span>.angle - <span class="keyword">this</span>.lastAppliedAngle;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 逆时针 &gt; 复位</span></span><br><span class="line">  <span class="keyword">if</span> (angleDiff &lt; <span class="number">0</span> &amp;&amp; angleDiff &gt; <span class="number">-355</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.rotateOrder = ANTI_CLOCKWISE;</span><br><span class="line">    <span class="keyword">this</span>.stop();</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      propellerReset.call(<span class="keyword">this</span>);</span><br><span class="line">    &#125;, <span class="number">200</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>rotateOrder 后续会用到。重置时注意设置一个超时（约 200 ms），保证 this.stop() 执行完再重置，否则动画会有跳帧抖动的现象。this.stop 会设置私有变量 this.active = false，当再次触发 this.update() 时会根据这个参数判断是否再次更新 DOM CSS。所以重置 propeller 的函数要手动调用一次 this.updateCSS()。</p>
<h4 id="旋转结束时的回调"><a href="#旋转结束时的回调" class="headerlink" title="旋转结束时的回调"></a>旋转结束时的回调</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onDragStart: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.rotateOrder = CLOCKWISE;</span><br><span class="line">&#125;,</span><br><span class="line">onDragStop: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.angle &amp;&amp; <span class="keyword">this</span>.rotateOrder === CLOCKWISE) &#123;</span><br><span class="line">      alert(<span class="string">'stop'</span>);</span><br><span class="line">      propellerReset.call(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>), <span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个判断放在了 onDragStop 中，这里的超时是为了等待 onRotate 复位的超时，从而获得 DOM 最后真正的 angle。<code>rotateOrder === CLOCKWISE</code> 保证了只有顺时针才继续后面的逻辑。当旋转开始时，会触发一次 onDragStart 事件，此时设置 this.rotateOrder = CLOCKWISE（相当于重置 this.rotateOrder，默认视为是顺时针），当出现了逆时针旋转时，this.rotateOrder = ANTI_CLOCKWISE，此时触发的 onDragStop 中就能识别出旋转的方向了。</p>
<blockquote>
<p>Propeller 还支持更多的参数：</p>
<ul>
<li><code>step</code> 每次转动一个指定的角度</li>
<li><code>inertia</code> 惯性旋转</li>
<li><code>stepTransitionEasing</code> 旋转动画的过度函数</li>
</ul>
</blockquote>
<p>感兴趣的可以自行探索哈</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-12-13</span><i class="fa fa-tag"></i><a href="/blog/categories/前端技术/" title="前端技术" class="tag">前端技术 </a><a href="/blog/tags/js/" title="js" class="tag">js </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,https://l19861225q.github.io/blog/2017/12/13/touch-rotate-with-one-finger/,6K,DOM 单触点旋转的探索,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/blog/2017/12/15/ios-fixed-input-cursor-position/" title="iOS 上，fixed 元素内的输入元素，获取焦点时的光标错位问题" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/blog/2017/10/11/fix-hammerjs-conflict/" title="解决 HammerJS 拖拽、缩放和旋转的手势问题" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/blog/js/jquery.js"></script><script src="/blog/js/jquery-migrate-1.2.1.min.js"></script><script src="/blog/js/jquery.appear.js"></script></body></html>